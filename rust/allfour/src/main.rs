mod algorithms;
mod lib;

use lib::SortingAlgorithm;

fn main() {
    let algorithm = lib::get_algorithm();
    let use_autogenerated_data = use_autogenerated_data();

    let mut data = if use_autogenerated_data {
        lib::get_random_data()
    } else {
        get_user_data()
    };

    println!("------[ BEFORE SORTING ]------");
    println!("{:?}", data);

    let start_time = std::time::Instant::now();
    match algorithm {
        SortingAlgorithm::InsertionSort => {
            algorithms::insertion::insertion_sort(&mut data);
        }
        SortingAlgorithm::BubbleSort => {
            algorithms::bubble::bubble_sort(&mut data);
        }
        SortingAlgorithm::MergeSort => {
            data = algorithms::merge::merge_sort(data);
        }
        SortingAlgorithm::QuickSort => {
            let length = data.len() as isize - 1;
            algorithms::quick::quick_sort(&mut data, 0, length);
        }
    }

    let end_time = start_time.elapsed();

    println!("------[ AFTER SORTING ]------");
    println!("{:?}", data);
    println!("Time taken: {:?}", end_time);

    if repeat_process() {
        main();
    }

}

fn repeat_process() -> bool {
    println!("Do you want to repeat the process? (y/n)");
    yes_no_print()
}

fn get_user_data() -> Vec<i64> {
    println!("Enter the data you want to sort (separate with blank space): ");
    let input = lib::read_console();

    let data: Vec<i64> = input
        .split_whitespace()
        .map(|x| x.parse::<i64>().unwrap())
        .collect();

    data
}
fn use_autogenerated_data() -> bool {
    println!("Do you want to use auto generated data? (y/n)");
    yes_no_print()
}

fn yes_no_print() -> bool {
    let string = lib::read_console();

    match string.trim().to_lowercase().as_str() {
        "y" => true,
        "n" => false,
        _ => use_autogenerated_data(),
    }
}
